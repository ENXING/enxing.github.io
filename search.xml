<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Numeric-hw04]]></title>
    <url>%2F2018%2FNumeric-hw04.html</url>
    <content type="text"><![CDATA[problem 1 Solution for any eigenvalue $\lambda$ of matrix $A$, there exists a corresponding eigenvector$X = \bf{0}$: $AX=\lambda X$.And we have $||A|| \cdot ||X||\geq||AX|| = ||\lambda X|| = |\lambda| ||X||$.So we get$|\lambda| \leq ||A||$, then $\rho(A) = {max}_{\lambda_i}{|\lambda_i| } \leq ||A||$ problem 2 Solution $A^2 - A = 0; A^2 X - A X = 0; \lambda ^2 - \lambda = 0;$So we have $\lambda = 0 , 1$ problem 3 Solution a Hermitian matrix (or self-adjoint matrix) is a complex square matrix that is equal to its own conjugate transpose. notice that eigenvalue of Hermitian matrix is real number. a) $\lambda &lt;x, y&gt; = &lt;\lambda x, y&gt; = &lt;Ax, y&gt; = $ $\ \ &lt;x, A^Hy&gt; = &lt;x, Ay&gt;= &lt;x, \mu y&gt; = \mu &lt;x, y&gt;, and \ \lambda \neq \mu$, So we get $y^Hx =0$. b) $\mu^H &lt;x, y&gt; = &lt;x, \mu^H y&gt; = &lt;x, A^Hy&gt; = $ $\ \ &lt;Ax, y&gt; = &lt;\lambda x, y&gt;= \lambda^H &lt;x, y&gt;, and \ \lambda \neq \mu$, So we get $y^Hx =0$. c) give a counterexample: $A = \begin{bmatrix} 1 &amp; 2 \\ 0 &amp; 2\end{bmatrix}$, for$\lambda = 1$, its eigenvector: $x = [1, 0 ]^T, and \ \ y = [0.4472, -0.8944]$, obviously we find $y^Hx\neq0$. problem 4 Solution a) As A is a real matrix of rank one, we know it must have non zero row $r_i$ that can linearly represent all the other row $r_j; j\neq i$.So we get $\begin{align}A&amp;=[ a_ 1 r_ i,a_2r_i,\cdots,a_ {i-1} r_ i, r_ i, a_ {i+1} r_ i , \cdots ,a_ n r_ i]^T \\ &amp;=[a_1 , a_2 ,\cdots , a_ {i-1} ,1 , a_ {i+1} ,\cdots ,a_n ]^T \cdot r_ i = u \cdot v^T\end{align}$and $v = r_i^T\ ;\ u =[a_1 , a_2 ,\cdot , a_{i-1} ,1, a_{i+1} ,\cdot ,a_n ]^T$ b) $uv^Tu = u\cdot v^Tu = v^Tu u$, so we get eigenvalue $v^Tu$ and corresponding eigenvector $u$. c) As A is a matrix of rank one, we know have $n-1$ eigenvalue equal to zero, and the rest one is $v^Tu$. d) problem 5 Solution As matrix of rank one has a property of Algebraic multiplicity equal to Geometric multiplicity, we know there exists an inverse matrix P,such that $uv^T = P^{-1} diag \{ v^Tu, 0 , 0 , 0, \cdots ,0 \} P$. So we have $det(I + uv^T) = det(I + diag\{v^Tu, 0 , 0 , 0, \cdots ,0 \}) = 1 + u^Tv$ problem 6 Solution Matrix A is similar to Jordan matrix J, So there is a inverse matrix P such that $P^{-1}AP = J$. Then $|I-A| = |I- J| = \prod_{i = 1}^{n}(1-J_{ii}) &gt; (1-\rho(A))^n \neq 0$ $(I- A) \cdot \Sigma_{k = 0}^{\infty}A^k = I$ problem 7 Solution problem 8 Solution problem 9if pivot should be used in the QR decomposition, how would you do in the QR iteration? Solution problem 10If a Martix is large and sparse, how would you find its largest 10 eigenvalues and eigenvectors? Solution problem 11Computer problem (in C or C++): Write the functions to achieve (1) Arnoldi iteration and Lanczos iteration; (2) QR iteration for Hessenburg matrix to find the eigenvalue decomposition. Test these algorithms for a few matrix. Solution problem 12 Solution problem 13 Solution problem 14Computer problem (in C or C++): Write the functions to achieve Newton’s method and Broyden’s method. Test these methods for a few equation systems. Solution]]></content>
      <categories>
        <category>Numeric</category>
      </categories>
      <tags>
        <tag>2018-fall</tag>
        <tag>numeric</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[encryption]]></title>
    <url>%2F2018%2Fencryption.html</url>
    <content type="text"><![CDATA[problem 1 [ Page 148, 3.30] Solution As the normal vector is: $v = \bf{a} - \alpha \bf{e_1}$, we need avoid cancellation. So the sign should be : $$\bf{-}sign(\bf{a}^T \cdot \bf{e_1})$$]]></content>
      <categories>
        <category>Numeric</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearnCode]]></title>
    <url>%2F2018%2FLearnCode.html</url>
    <content type="text"><![CDATA[C++Learning C++ Coding Skill 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473/* * g++ -O3 -Wall --std=c++11 qr_standalone.cpp -o qr_standalone */#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string&gt; #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;class Vector; class Matrix &#123; public: // default constructor (don't allocate) Matrix() : m(0), n(0), data(nullptr) &#123;&#125; // constructor with memory allocation, initialized to zero Matrix(int m_, int n_) : Matrix() &#123; m = m_; n = n_; allocate(m_,n_); &#125; // copy constructor Matrix(const Matrix&amp; mat) : Matrix(mat.m,mat.n) &#123; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) (*this)(i,j) = mat(i,j); &#125; // constructor from array template&lt;int rows, int cols&gt; Matrix(double (&amp;a)[rows][cols]) : Matrix(rows,cols) &#123; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) (*this)(i,j) = a[i][j]; &#125; // destructor ~Matrix() &#123; deallocate(); &#125; // access data operators double&amp; operator() (int i, int j) &#123; return data[i+m*j]; &#125; double operator() (int i, int j) const &#123; return data[i+m*j]; &#125; // operator assignment Matrix&amp; operator=(const Matrix&amp; source) &#123; // self-assignment check if (this != &amp;source) &#123; if ( (m*n) != (source.m * source.n) ) &#123; // storage cannot be reused allocate(source.m,source.n); // re-allocate storage &#125; // storage can be used, copy data std::copy(source.data, source.data + source.m*source.n, data); &#125; return *this; &#125; // compute minor void compute_minor(const Matrix&amp; mat, int d) &#123; allocate(mat.m, mat.n); for (int i = 0; i &lt; d; i++) (*this)(i,i) = 1.0; for (int i = d; i &lt; mat.m; i++) for (int j = d; j &lt; mat.n; j++) (*this)(i,j) = mat(i,j); &#125; // Matrix multiplication // c = a * b // c will be re-allocated here void mult(const Matrix&amp; a, const Matrix&amp; b) &#123; if (a.n != b.m) &#123; std::cerr &lt;&lt; "Matrix multiplication not possible, sizes don't match !\n"; return; &#125; // reallocate ourself if necessary i.e. current Matrix has not valid sizes if (a.m != m or b.n != n) allocate(a.m, b.n); memset(data,0,m*n*sizeof(double)); for (int i = 0; i &lt; a.m; i++) for (int j = 0; j &lt; b.n; j++) for (int k = 0; k &lt; a.n; k++) (*this)(i,j) += a(i,k) * b(k,j); &#125; void transpose() &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; double t = (*this)(i,j); (*this)(i,j) = (*this)(j,i); (*this)(j,i) = t; &#125; &#125; &#125; // take c-th column of m, put in v void extract_column(Vector&amp; v, int c); // memory allocation void allocate(int m_, int n_) &#123; // if already allocated, memory is freed deallocate(); // new sizes m = m_; n = n_; data = new double[m_*n_]; memset(data,0,m_*n_*sizeof(double)); &#125; // allocate // memory free void deallocate() &#123; if (data) delete[] data; data = nullptr; &#125; int m, n; private: double* data; &#125;; // struct Matrix // column vectorclass Vector &#123; public: // default constructor (don't allocate) Vector() : size(0), data(nullptr) &#123;&#125; // constructor with memory allocation, initialized to zero Vector(int size_) : Vector() &#123; size = size_; allocate(size_); &#125; // destructor ~Vector() &#123; deallocate(); &#125; // access data operators double&amp; operator() (int i) &#123; return data[i]; &#125; double operator() (int i) const &#123; return data[i]; &#125; // operator assignment Vector&amp; operator=(const Vector&amp; source) &#123; // self-assignment check if (this != &amp;source) &#123; if ( size != (source.size) ) &#123; // storage cannot be reused allocate(source.size); // re-allocate storage &#125; // storage can be used, copy data std::copy(source.data, source.data + source.size, data); &#125; return *this; &#125; // memory allocation void allocate(int size_) &#123; deallocate(); // new sizes size = size_; data = new double[size_]; memset(data,0,size_*sizeof(double)); &#125; // allocate // memory free void deallocate() &#123; if (data) delete[] data; data = nullptr; &#125; // ||x|| double norm() &#123; double sum = 0; for (int i = 0; i &lt; size; i++) sum += (*this)(i) * (*this)(i); return sqrt(sum); &#125; // divide data by factor void rescale(double factor) &#123; for (int i = 0; i &lt; size; i++) (*this)(i) /= factor; &#125; void rescale_unit() &#123; double factor = norm(); rescale(factor); &#125; int size; private: double* data; &#125;; // class Vector // c = a + b * svoid vmadd(const Vector&amp; a, const Vector&amp; b, double s, Vector&amp; c)&#123; if (c.size != a.size or c.size != b.size) &#123; std::cerr &lt;&lt; "[vmadd]: vector sizes don't match\n"; return; &#125; for (int i = 0; i &lt; c.size; i++) c(i) = a(i) + s * b(i);&#125; // mat = I - 2*v*v^T// !!! m is allocated here !!!void compute_householder_factor(Matrix&amp; mat, const Vector&amp; v)&#123; int n = v.size; mat.allocate(n,n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) mat(i,j) = -2 * v(i) * v(j); for (int i = 0; i &lt; n; i++) mat(i,i) += 1; &#125; // take c-th column of a matrix, put results in Vector vvoid Matrix::extract_column(Vector&amp; v, int c) &#123; if (m != v.size) &#123; std::cerr &lt;&lt; "[Matrix::extract_column]: Matrix and Vector sizes don't match\n"; return; &#125; for (int i = 0; i &lt; m; i++) v(i) = (*this)(i,c);&#125; void matrix_show(const Matrix&amp; m, const std::string&amp; str="")&#123; std::cout &lt;&lt; str &lt;&lt; "\n"; for(int i = 0; i &lt; m.m; i++) &#123; for (int j = 0; j &lt; m.n; j++) &#123; printf(" %8.4f", m(i,j)); &#125; printf("\n"); &#125; printf("\n");&#125; // L2-norm ||A-B||^2double matrix_compare(const Matrix&amp; A, const Matrix&amp; B) &#123; // matrices must have same size if (A.m != B.m or A.n != B.n) return std::numeric_limits&lt;double&gt;::max(); double res=0; for(int i = 0; i &lt; A.m; i++) &#123; for (int j = 0; j &lt; A.n; j++) &#123; res += (A(i,j)-B(i,j)) * (A(i,j)-B(i,j)); &#125; &#125; res /= A.m*A.n; return res;&#125; void householder(Matrix&amp; mat, Matrix&amp; R, Matrix&amp; Q)&#123; int m = mat.m; int n = mat.n; // array of factor Q1, Q2, ... Qm std::vector&lt;Matrix&gt; qv(m); // temp array Matrix z(mat); Matrix z1; for (int k = 0; k &lt; n &amp;&amp; k &lt; m - 1; k++) &#123; Vector e(m), x(m); double a; // compute minor z1.compute_minor(z, k); // extract k-th column into x z1.extract_column(x, k); a = x.norm(); if (mat(k,k) &gt; 0) a = -a; for (int i = 0; i &lt; e.size; i++) e(i) = (i == k) ? 1 : 0; // e = x + a*e vmadd(x, e, a, e); // e = e / ||e|| e.rescale_unit(); // qv[k] = I - 2 *e*e^T compute_householder_factor(qv[k], e); // z = qv[k] * z1 z.mult(qv[k], z1); &#125; Q = qv[0]; // after this loop, we will obtain Q (up to a transpose operation) for (int i = 1; i &lt; n &amp;&amp; i &lt; m - 1; i++) &#123; z1.mult(qv[i], Q); Q = z1; &#125; R.mult(Q, mat); Q.transpose();&#125;//*********************************************************************************double in[21][12];double y[21][1];double Epsilon = 1E-10; double pwr(double a, int n)&#123; if (n == 0) return 1; double tmp = 1; for (int i = 0; i &lt; n; ++i) &#123; tmp *= a; &#125; return tmp;&#125;double poly(double t)&#123; double f = 0; for (int i = 0; i &lt; 12; ++i) &#123; f += pwr(t, i); &#125; return f;&#125;void initial(double m[21][12])&#123; for (int i = 0; i &lt; 21; ++i) &#123; for (int j = 0; j &lt; 12; ++j) &#123; m[i][j] = pwr(i /20.0, j); &#125; &#125; srand((unsigned)time(NULL)); double u[21]; for (int i = 0; i &lt; 21; ++i) &#123; u[i] = (2* rand() / 1.0 / RAND_MAX - 1) * Epsilon; &#125; for (int i = 0; i &lt; 21; ++i) &#123; y[i][0] = poly(i / 20.0) + u[i]; &#125;&#125;//*********************************************************************************int main()&#123; initial(in); Matrix A(in); Matrix Y(y); Matrix Q, R; matrix_show(A,"A"); // compute QR decompostion householder(A, R, Q); matrix_show(R,"R"); matrix_show(Q,"Q"); #if 0 // compare Q*R to the original matrix A Matrix A_check; A_check.mult(Q, R); // compute L2 norm ||A-A_check||^2 double L2 = matrix_compare(A, A_check); // display Q*R matrix_show(a_check, l2 &lt; 1e-12 ? "a == q * r ? yes" : "a == q * r ? no");#endif // matrix_show(Q,"Q"); // matrix_show(R,"R"); Matrix copy_Q(Q); Q.transpose(); Matrix copy_R(R); Matrix yy;//yy = Q'Y; yy.mult(Q, Y); for (int j = 11; j &gt;= 0; j--) &#123; double factor = 1 / copy_R(j, j); copy_R(j, j) = 1; yy(j, 0) *= factor; for (int i = j - 1; i &gt;= 0; --i) &#123; yy(i, 0) -= yy(j, 0) * copy_R(i, j); copy_R(i, j) = 0; &#125; &#125; std::cout &lt;&lt;"Solution "&lt;&lt; std::endl; for (int i = 0; i &lt; 12; ++i) &#123; printf(" %2.10f\n", yy(i,0)); &#125; printf(" \n\n"); std::cin.get(); return EXIT_SUCCESS;&#125;]]></content>
      <categories>
        <category>Code</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VIM_NOTE]]></title>
    <url>%2F2018%2FVIM-NOTE.html</url>
    <content type="text"><![CDATA[MARK1.设置标签ma 在当前位置设立一个标签名字是a，这是一个局部标签，只在当前文件内有效。如果要设置全局标签，在多个文件之间跳转的话，只要将标签名字大写就可，即mA。2.标签跳转`a 跳转到标签a的位置3.标签删除 delmarks a4.查看当前设置的标签 ：marks]]></content>
      <categories>
        <category>NOTE</category>
      </categories>
      <tags>
        <tag>NOTE</tag>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numeric-hw03]]></title>
    <url>%2F2018%2FNumeric-hw03.html</url>
    <content type="text"><![CDATA[problem 1 [ Page 148, 3.30] Solution As the normal vector is: $v = \bf{a} - \alpha \bf{e_1}$, we need avoid cancellation. So the sign should be : $$\bf{-}sign(\bf{a}^T \cdot \bf{e_1})$$ problem 2 [ Page 148, 3.33] Solution (Reference) LU factorization Of A: if no using partial pivoting, No additional storage of memory is needed except storage of matrix A. if using partial pivoting, the permutation matrix P need to be stored, and only need an extra storage of $(n - 1) \times 2$ array. QR factorization of A: only need an extra storage of $m \times 1$ array. Following Graph: problem 3 [ Page 149, 3.44] Solution Matrix elementary transformation. find max integer r, such that there is a sub-square-matrix formed by entries intersected by r rows and r columns of rectangular matrix and that determinant is no equal to zero. QR-Householder decomposition, observe matrix R, can easily get rank. Singluar Value Decomposition, observe non-zero of diagonal matrix. problem 4 [ Page 149, 3.45] Solution $(c) &gt; (a) &gt; (b)$ problem 5 [ Page 149, 3.1 ] Solution $\begin{bmatrix}1 &amp; 10 \\ 1 &amp; 15 \\ 1&amp; 20 \end{bmatrix} \begin{bmatrix}x_1\\ x_2\end{bmatrix}=\begin{bmatrix}11.60\\ 11.85\\ 12.25 \end{bmatrix}$ inconstitent. $x_1 = 11.10 ,\ x_2 = 0.05 (eqn \ 1 \ and \ 2)$ $x_1 = 10.65,\ x_2 = 0.08 (eqn \ 2 \ and \ 3)$ There is no reason to prefer any one of these result. normal equation: $A = \begin{bmatrix}1 &amp; 10 \\ 1 &amp; 15 \\ 1&amp; 20 \end{bmatrix}$ ; $b= \begin{bmatrix}11.60\\ 11.85\\ 12.25 \end{bmatrix}$ $A^{T} \cdot A x = A^T b$ $x_1 = 10.9250, \ x_2 = 0.0650$ the result got by normal equation is better than those obtain in part b, and that seems to be certain average of possible pair of values obtained by selecting any two of the equation from the system. problem 6 [ Page 149, 3.3 ] Solution $\begin{bmatrix}1 &amp; e \\ 2 &amp; e^2 \\ 3 &amp; e^3 \end{bmatrix} \begin{bmatrix}x_1 \\ x_2\end{bmatrix}=\begin{bmatrix}2 \\ 3\\ 5 \end{bmatrix}$ $A = \begin{bmatrix}1 &amp; e \\ 2 &amp; e^2 \\ 3 &amp; e^3 \end{bmatrix} \ and \ b = \begin{bmatrix}2\\ 3\\ 5 \end{bmatrix}$ normal equation: $A^{T} \cdot A x = A^T b$ $(x_1,\ x_2) = ( 1.5942, \ 0.0088)$ problem 7 [ Page 150, 3.14 ] Solution orthogonal : $H^T* H = I$ $H^T*H = (I - 2\frac{vv^T}{v^Tv})^T\cdot (I - 2\frac{vv^T}{v^Tv})$ $=I - 2 \frac{vv^T}{v^T v} - 2 [\frac{vv^T}{v^T v}]^T +4 [\frac{vv^T}{v^T v}]^T * [\frac{vv^T}{v^T v}] = I$ symmetric: $H^T = H$ ; Obviously. problem 8 [ Page 152, 3.31 ] Solution (Reference) $A^T A X= A^Tb$ $\Rightarrow X = (A^TA)^{-1} A^T b; \ A = U\Sigma V^T$ $\Rightarrow X = ( [U\Sigma V^T]^TU\Sigma V^T)^{-1} [U\Sigma V^T]^T b$ $\Rightarrow X = ( V\Sigma^T\Sigma V^T)^{-1} V\Sigma^T U^T b$ $\Rightarrow X = V\Sigma^{-1}(\Sigma^T)^{-1} V^{-1} V\Sigma^T U^T b$ $\Rightarrow X = V\Sigma^{-1}(\Sigma^T)^{-1} \Sigma^T U^T b$ $\Rightarrow X = V\Sigma^{-1} U^T b$ $\Rightarrow X = V\Sigma^{+} U^T b$ $U = [u_1 , u_2, \cdots , u_n]; V=[v_1, v_2, \cdots, u_n]; $ $\Sigma^{+} = diag[1/\sigma_1 , 1/\sigma_2, \cdots, 1/\sigma_r, 0 ,0 ]$ So we get $X = \sum_{\sigma_i \neq 0} \frac{u_i^Tb}{\sigma_i}v_i$ problem 9 [ Page 152, 3.32 ] Solution $AA^+A = U\Sigma V^T \cdot V\Sigma ^+U^T\cdot U\Sigma V^T = U\Sigma V^T= A$ $A^+AA^+ =V\Sigma ^+U^T\cdot U\Sigma V^T \cdot V\Sigma ^+U^T =V\Sigma ^+U^T= A^+$ $(A^+A)^T= A^+A$ $(A^+A)^T =(V\Sigma ^+U^T\cdot U\Sigma V^T )^T=V{ \Sigma ^T \Sigma ^+}^T V^T$ $A^+A =V\Sigma ^+U^T \cdot U\Sigma V^T=V\Sigma ^+\Sigma V^T$ Obviously $\Sigma^+\Sigma = (\Sigma^+\Sigma)^T$ $(AA^+)^T= AA^+$ for the same reason, can be proved. problem 10Computer problem (in C or C++): Using Householder transform to achieve the QR decomposition with and without a column pivoting. Then, using QR decomposition to finish 3.8 on page 154. Code Download Cholesky factorization is more sensitive, I think. QR method comes closer to recovering the x that we used to generate the data! Not affect. As it exists the random error, having different solutions is not weird, and we can average the solutions generate by QR method.]]></content>
      <categories>
        <category>Numeric</category>
      </categories>
      <tags>
        <tag>2018-fall</tag>
        <tag>numeric</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numeric-hw02]]></title>
    <url>%2F2018%2FNumeric-hw02.html</url>
    <content type="text"><![CDATA[2018年9月23日 Homework02 本次作业的源码下载链接 Problem 1 [Page94, 2.45] Solution不能直接求矩阵$A$的逆矩阵，否则计算量太大了。设$A^{-1}Bc = x$,则有$Ax=Bc$，那么右端一个矩阵乘以一个向量，计算量很小，然后求解线性方程$Ax=b, b= Bc$，可以用LU 分解等等。 problem 2 [Page 95, 2.48] Solution $A^{T} = U^{T} L^{T}$ , $U^{T}$是下三角，而$L^{T}$是上三角，因此只考虑$A=LU, Ax=b$： 如果$A$矩阵已经分解成三角形式$A=LU$，那么可以通过两步过程求解出$x$，首先，设$y=Ux$，然后对$y$解方程组$Ly=b$。因为$L$是三角形的，从这个方程确定$y$仅需要$O(n^2)$运算。一旦$y$已知，上三角方程组$Ux=y$仅需要另外的$O(n^2)$运算来确定解$x$。 problem 3 [Page 95, 2.49] Solution （a）下三角矩阵$Ly=b$只需要$O(n^2 )$计算量，然后置换矩阵$Px =y$只需进行 行交换 可得单位阵而得到求解。 （b）$PLx = b$，这个先对$Py =b$,进行行交换将左端矩阵变成单位阵即可求解，然后 $Lx=y$进行高斯消元只需$O(n^2)$计算量。 problem 4 [Page 95, 2.51] Solution 可能，如 $x = (4, 4), y=(5, 1)$。 problem 5 [Page 95, 2.52] Solution $|A|_1$: 是各列1范数的最大值，这个更加容易计算。 problem 6 [page95, 2.57] Solution A=$\begin{bmatrix}4 &amp; 0 &amp; 0\\ 0 &amp; -6 &amp; 0 \\ 0&amp; 0&amp;2 \end{bmatrix}$ $cond(A) = |A|_1 \cdot |A^{-1}|_1 = 6 * 0.5 = 3$ $cond(A) = |A|_ {\infty} \cdot |A^{-1}|_ {\infty} = 6 * 0.5 = 3$ problem 7 [Page 95, 2.61] Solution a) $cond(A) = 10^ {10} * 10^ {10} = 10^ {20}$ b) $cond(A) = 10^{10} * 10^{-10} = 1$ c) $cond(A) = 10^{-10} * 10^{10} = 1$ d) $cond(A) = 6 * \infty = \infty$ problem 8 [Page 96, 2.77] Solution $\begin{bmatrix} 4 &amp; 2\\ 2&amp;2\end{bmatrix} =\begin{bmatrix} 2 &amp; 0\\ 1&amp;1\end{bmatrix} \cdot \begin{bmatrix} 2 &amp; 1\\ 0&amp;1\end{bmatrix} $ problem 9 [Page 97, 2.10] Solution A permutation matrix is a matrix obtained by permuting the rows of an identity matrix according to some permutation of the numbers 1 to . Every row and column therefore contains precisely a single 1 with 0s everywhere else, and every permutation corresponds to a unique permutation matrix. 显然任意行交换矩阵 可以表示成多个单一行交换矩阵连乘: $P = P_1 P_2 P_3 \cdots P_k， P_i^T = P_i, P_i^ {-1} = P_i$ 那么有 $P^T= P_k^T P_ {k-1}^T P_ {k-2}^T \cdots P_k^T = P_k P_ {k-1} P_{k-2} \cdots P_1$ $P * P^T = P_1 P_2 P_3 \cdots P_k \cdot P_k P_ {k-1} P_{k-2} \cdots P_1 = I$ (另一种证明) $P = (e_ {i_1}, e_ {i_2}, e_ {i_3} \cdots e_ {i_n}), P^T = (e_ {i_1}^T, e_ {i_2}^T, e_ {i_3}^T \cdots e_ {i_n}^T)^T$ 显然： $P*P^T= I$ problem 10 [Page 98, 2.31] Solution 1) $||x||&gt;0$ if $x \neq 0$ 2) $||\gamma x|| = |\gamma | \cdot ||x||$ 3) $||x+y|| \leq ||x|| + ||y||$ 第一条更加正定矩阵的定义显然成立。 $||\gamma x|| =((\gamma x) ^T A \gamma x)^ {\frac{1}{2}} = |\gamma| ||x||$ 第二条成立。 \begin{equation}||x+y|| \leq ||x|| + ||y|| \Leftrightarrow [(x+y)^{T} A (x+y)]^{\frac{1}{2}} \leq (x^{T} A x)^{\frac{1}{2}} + (y^{T} A y)^{\frac{1}{2}} \ \ (1)\end{equation} 由于矩阵$A$ 是对称矩阵，那么存在正交矩阵$U$，使得$A = U^T D U$，由于$A$正定 因而有$D$是对角元恒正的对角矩阵，并且$D = d^T d, d_{ii}^2 = D_{ii}, \ d_{ii} &gt; 0;\ d_{ij} = 0 ,\ if: i \neq j$。令$\hat{x} = dU x; \ \hat{y} = dU y$， 则由(1)有 $[(\hat{x} + \hat{y})^T \cdot (\hat{x} + \hat{y})]^{\frac{1}{2}} \leq [\hat{x}^T \cdot \hat{x}]^{\frac{1}{2}} + [\hat{y}^T \cdot \hat{y} ]^{\frac{1}{2}}\Leftrightarrow ||x+y||_2 \leq ||x||_2 + ||y|_2|$，显然成立！ problem 11Computer problem (in C or C++): Using Gaussian elimination to achieve the LU decomposition with and without a column pivoting; Using the two LU decomposition algorithm to solve linear systems in which the coefficient matrix is (1) general nonsingular matrix; (2) positive definite matrix; (3) diagonally dominant matrix. Compare the numerical accuracy for the two algorithms. The size of the matrices should be greater than 1000. code download nonsingular matrix : 选偏主元与否会影响精度，如下图：（选主元的误差会比不选主元的误差小三倍左右） Diagonally dominant matrix: 选偏主元与否不影响精度。]]></content>
      <categories>
        <category>Numeric</category>
      </categories>
      <tags>
        <tag>2018-fall</tag>
        <tag>numeric</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numeric-hw01]]></title>
    <url>%2F2018%2FNumeric-hw01.html</url>
    <content type="text"><![CDATA[2018年9月19日 Homework01 本次作业的源码下载链接 Problem 1 [Page 45 1.7] Solution 中心差分 可以看出当$k=10^{-8}$ 达到误差最小，是由于其与分子的双精度误差的开方可比拟的缘故。 和例子1.3 很契合。 向前差分 可以看出当$k=10^{-6}$ 达到误差最小，并不和$h \approx \sqrt{\epsilon_{mach}}$ 一致。 Problem 2 [Page 46 1.9] Solution (b)通过计算: $\frac{x^n}{n!}$ 小于 计算机双精度$10^{-16}$作为计算停止准则。 (c)计算结果如下： (d) 对于负数，由于级数相邻两项符号不一致，而且大小在一个数量级上，相减会丢失精度。所以对负数情况可以求对应的正数再取倒数，测试结果如下: (e) 对负数情况进行分组求和，如将正的放在一起和负的放在一起，最后相减(数值结果如下图)，等操作无法改善精度， 归根究底就是两个想近数相减引起的。因此可以下结论，交换重组项无法改善精度。 $$e^{-x} = (\frac{x^{0}}{0!} +\frac{x^{2}}{2!}+ \frac{x^{4}}{4!} +\cdots ) -(\frac{x^{1}}{1!} +\frac{x^{3}}{3!}+ \frac{x^{5}}{5!} +\cdots )$$ Problem 3 [Page 46 1.9](Matlab test) For $n=500, 1000,2000, 4000, 8000$, generate an $n\times n$ random matrix B, and an $n\times 1$ vector b. Find the symmetric matrix $A=B^{\tau} \cdot B$1) Using function “eig” to test the time cost for eigen decomposition;2) Using $x=A / b$, and $x=A^{-1}\cdot b$ to test the time cost in finding the solution of $Ax=b$;3) Plot all the time costs as a function of n and the power law for the time costs. Solution 1) 计算结果如下：计算时间耗时： 2) 计算结果如下：$t_1$是没有求逆矩阵求解线性方程所用时间。$t_2$是有求逆矩阵求解线性方程所用时间。不同分量对应不同的维数的矩阵求解时间。 3) 如下图：蓝线是有求逆矩阵的维数对时间的 $log$ 曲线。红线是没有求逆矩阵的维数对时间的 $log$ 曲线。]]></content>
      <categories>
        <category>Numeric</category>
      </categories>
      <tags>
        <tag>2018-fall</tag>
        <tag>numeric</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transport03]]></title>
    <url>%2F2018%2Ftransport03.html</url>
    <content type="text"><![CDATA[Boltzmann equation$$ f(t, \vec{x}, \vec{u}) \leftarrow evolution$$ the number of moecules in a $d^3\vec{x}$ volume element and $d^3u\vec{u}$ velecity element compact cas-kinetic scheme(gks) 一个有希望的方向compact 4-rd order GKS]]></content>
  </entry>
  <entry>
    <title><![CDATA[transport01]]></title>
    <url>%2F2018%2Ftransport01.html</url>
    <content type="text"><![CDATA[Book: 输运理论 黄祖洽 multiscale Transport modeling &amp; computationgas dynamics: navier-stokes equation : $k_n = \frac{l}{L}$ flud element hydrodyamic （宏观） boltzmam equation “particle” mean free path kinetic scale （介观） radiative transfer (optical thick) 光子和物质相互作用 optical thick diffusion plasma -vlasov eqn 无碰撞 + maxwell + two phase flow magnetic-hydrodynamics two fluid model hall MHD ~ ~ ~ idea magnetic-hydrodynamics different level of description microscopic （微观）( resolution to particle ) Hamiltonian - Newton’s Law indiviual paritcle $$P_r = -\frac{\partial H}{\partial q_r}$$ $$q_r = - \frac{\partial H}{\partial p_r}, r = 1,2,…3N$$ $$ H = \sum_{1}^{N} kinetic + potential$$ mesoscopic （介观） (不能跟踪每个粒子 ) mean free path 空间自由程$l_1$ collustion time $\tau_1$ botzmann eqn &amp; distribution function $\rho(x,t,u)$ 7-dim 微观 推导 介观 （BBGKY) 无法给出中间尺度 macroscopic (宏观) Navier-stoks MHD two phase flow multiphase flow $$ \rho , V, T (x, t): 4-dim $$ Newtone -&gt; boltzmann -&gt; NSsingle particle .. 尺度逐渐变大Boltzmann -&gt; NS chapmann enskog expansion burelt supris~ moments – Grad 13, 26, 35 距方程 中间尺度 (非平衡物理 unexplore)： “shock Structure”可能的理论 Difficulties degree of freedom NS (5 degree) conservation law $\rho , \rho v,\rho E$ Boltzmann($\infty$ degree) 不是守恒量的确定方程 自然界没有: $$ \frac{\partial T_x}{\partial t} + ……$$$$ \frac{\partial T_{xy}}{\partial t} + ……$$ Discontinuous Galerkin “DG” 网格有更多自由度提高精度 (相当于对原控制方程求) $$\frac{\partial}{\partial x} : \rho _x + (\rho u)_x =0$$ compact high-order 不是直接建模不可能成功 从Boltzmann 方程直接推出中间尺度 ，难成功 Bolzmann 两体碰撞 trasnsport &amp; collision decouple $\delta t \leq \tau, \delta x \leq l$ 前提 如果$\Delta x \approx 5l, \Delta t \approx 5\tau$ ，未知领域 Numericall metheds macro NS MHD multiphase Numerical PDE Boltzmann DVM SN vlasov particle methods Direct simulation monte carlo (DSMC, bird 1960) 稀波流 稀薄气体 IMC PIC $\Delta x\sim \frac{l}{3}, \Delta t \sim \frac{\tau}{3} , 64nm$ 计算量巨大 multiscale modeling Scale $(\Delta x,\Delta t)$ discrete governing eqn computation (多尺度) $m=10$,飞机头部密度非常大，飞机尾部几乎真空。 空天飞机，网格机头部分粒子很多NS eqn，尾翼粒子稀薄Boltzmann eqn 卫星喷管，箱内密度很高NS方程，喷嘴外真空。 Contents NS eqn continuum mechanics 连续介质流体 用微积分 离散更有优势。 两个粒子黏在一块。 流体微团没有物质交换 Boltzmann Eqn Unified gas Kinetic Scheme rarefied gas raiation Newton transport plasma two phase Particle Version 化学反应 Navier-Stokes Equation : flud gas Navier-Stokes Equation : flud gas$\rho = \frac{\Delta m}{\Delta v}$ kinematic properties: Velocity acceleration vorticity transport properties: viscosity , thermal conductivity Thermodynamic properties: pressure, density temperature location: $X(t),Q(X(t),t)$ $\frac{dQ}{dt} = \frac{\partial Q}{\partial t} + \frac{\partial Q}{\partial X}\frac{\partial X}{\partial t} +\frac{\partial Q}{\partial Y}\frac{\partial Y}{\partial t} + \frac{\partial Q}{\partial Z}*\frac{\partial Z}{\partial t}$ $= \frac{\partial Q}{\partial t} +V \cdot \nabla Q$ $$\frac{DQ}{Dt} = \frac{dQ}{t} = \frac{\partial Q}{\partial t} + \vec{V} \cdot \nabla Q $$$$ \vec{V} \cdot \nabla \vec{V} = \nabla \frac{\vec{V}^2}{2} - \vec{V} \times (\nabla \times \vec{V})$$ $$ \vec{w} = \nabla \times \vec{V}$$ Vorticity: $$ \frac{DV_i}{Dt} = \frac{\partial V_i}{\partial t} + V_j \partial V_i$$ translation (3-degree) rotation (3-degree) extensional strain(3-degree) shear strain(3-degree) Scale Vector second order tensor $$\nabla V = 0.5 (\nabla V + (\nabla V)^T)_ (shear Strain) + 0.5 (\nabla V - (\nabla V)^T)_ (rotation)$$ 反对称张量只有三个自由度 对称张量有六个自由度 $\epsilon_{ij} = 0.5(\partial_j V_i + \partial_i V_j)$ 应变 stress：$\tau_{ij} = f(\epsilon_{ij})$应力 Newton fluid $\tau_{ij} \sim \epsilon_{ij}$ Non Newton fluid $F \sim \alpha \frac{dV}{dy}$ 满足此式是牛顿流体 $\tau_{\alpha \beta}e_{\alpha}e_{\beta}$ $\alpha$ direction of normal $\alpha$ direction of force $f = n \cdot \tau = f_n + f_t$ $f_n = (n \cdot f)$ $f_n = (n \cdot f) n = n \cdot (n \cdot \tau) n = (n n : \tau) n$ $f_t = f - f_n = n \cdot \tau - (nn: \tau) n = f \cdot (I - n n)$ $\tau \sim (\nabla V + (\nabla V)^{T})$ Symmetric tensor $moment = I\frac{dW}{dt} -&gt; 0$ 力矩 $\int\int (r \times f) ds = I \frac{dw}{dt}$ $f = n\cdot \tau$ 流体微团趋于零：$\tau_{ij} = \tau_{ji}$ $$\tau_{ij} = -P \delta_{ij} (hyrostatic Pressure) + \mu[\frac{\partial V_i}{\partial x_j}+\frac{\partial V_i}{\partial x_j} - \frac{2}{3} \nabla \cdot \vec{V}]$$ Equation of compressible Viscous flow mass conservation 流体微团: 跟着流体微团：$\frac{Dm}{Dt} = 0$ $ \frac{D}{Dt} (\rho V) = \rho \frac{DV} {Dt} + V \frac{D\rho }{Dt}= 0$ $=\rho v \nabla v + v \frac{D\rho}{Dt}$ $\frac{D V}{Dt} / V = \nabla \cdot V$ $$V (\rho \nabla \cdot V + \frac{\partial\rho}{\partial t} + V \cdot \nabla \rho) =0$$$$\frac{\partial \rho}{\partial t} + \nabla \cdot (\rho V)= 0$$ monmentum Eq:$$\frac{\rho v V}{Dt} = body force + surface force$$$$\rho v \frac{DV}{Dt} = \rho V g + v V \cdot \tau$$$$\rho \frac{DV}{Dt} = \rho \vec{g} + \nabla \tau$$ $$\frac{\partial \rho V}{\partial t} + V\cdot (\rho VV - \tau) = \rho g$$ $$\vec{f}_{surface} = \int \int \tau \cdot n dt = \int \int \int \nabla \cdot \tau dv = \nabla \cdot \tau V$$ Energy Eqn: (流体微团)1st-laws of thermaodynamics:$$E = \rho \hat{V}(e + 0.5 V^2 - g \cdot r)$$ $m= \rho \hat{V}= const$ $$\frac{DE}{Dt} = \frac{DQ}{Dt} + \frac{DW}{Dt}$$ 热交换 对外做功 $$\frac{DQ}{Dt} = \int\int -q \cdot n dx = -\int \int \int - \nabla \cdot q dV = -\nabla \cdot q \hat{V}$$ Assumption Fourier’s Law : $q = -R \nabla T$ (其中一个假设，可换成其他 不一定对) $$q \approx g$$ $$\frac{DW}{Dt} = \int \int (\tau \cdot n)\cdot V dS = \int \int v \cdot (\tau \cdot n) ds$$ $$= \int \int \int \nabla \cdot (V \cdot \tau)dV = \nabla\cdot (V\cdot \tau)\cdot V$$ (力点乘速度等于功) $$\rho (\frac{De}{Dt} + \frac{D(\frac{1}{2} V^2)}{Dt} + \frac{D}{Dt} (-g \cdot r)) = \nabla \cdot (k \nabla T) + \nabla \cdot (V \cdot \tau)$$ e : internal energy (therinal )for unit mass 粒子3个translation degree ， 粒子内部旋转振动有k个自由度。 each egreee of reedom shares the same amount of energy m: molecula mass $$e = \frac{1}{m} ( k + 3) \frac{1}{2}\hat{k} T$$ $\hat{k}$ : : Boltzomann constant , T temperature $C_v$ specific heat at constant volume $C_p$, at constant pressure $r,R$ $$ \delta Q= C_v dT$$ $$de = \frac{1}{m} \frac{k+3}{2} \hat{k} dT = C_v dT = \frac{k + 3}{2} R dT$$ $$C_v = \frac{k + 3}{2}R , \frac{k}{m} =R$$ 加多少热量保持压力不变： $$\delta Q = C_p dT = C_v dT + P dV = C_vdT + R dT$$ $p = \rho R T , p = \frac{1}{V} RT, PV = RT$ $$C_p = C_v + R = \frac{k + 3 +2 }{2}R$$ $$\gamma = \frac{C_p}{C_v} = \frac{k + 5}{k + 3} = 5/3 ,k =0; 7/5 = 1.4,k=2; isothermal, k= \infty;$$ energy:$$\rho (\frac{De}{Dt} + \frac{D \frac{1}{2}V^2}{Dt}) = \nabla \cdot (V\cdot \tau) \text{流体加速运动} + \nabla\cdot (\hat{k} \nabla T) \text{热量}$$ momentum:$$\rho \frac{DV}{Dt} = \nabla \cdot \tau$$ $$\nabla \cdot (V \cdot \tau) = V \cdot (\nabla \cdot \tau) + \tau_{ij} \frac{\partial V_i}{\partial x_j}$$ thermal energy eqn: $$\rho \frac{De}{Dt} = \nabla \cdot (\hat{k} \nabla T) + \tau_{ij} \frac{\partial u_i}{\partial x_j}$$ $$\tau = -P \delta_{ij} + \sigma_{ij}$$ $$P \nabla \cdot V = -\frac{P}{\rho} \frac{D\rho}{Dt} = \rho \frac{D}{Dt} \frac{p}{\rho} - \frac{D\rho}{Dt}$$ $$\rho \frac{D}{Dt} (e + \frac{p}{\rho}) = \frac{DP}{Dt} + \nabla\cdot (\hat{k} \nabla T) + \sigma_{ij} \frac{\partial V_i}{\partial x_j} (heat)\geq 0$$ $$\rho \frac{Dh}{Dt} = \frac{Dp}{Dt} + \nabla \cdot (\hat{k} \nabla T) + \Phi $$ termodynamic identity: $$dh = C_p T + (1+ 1/\rho (\frac{\partial \rho}{\partial T})_p T \frac{dp}\rho$$ low speed incompressible flow: $$\rho c_p \frac{DT}{Dt} = \nabla \cdot (\hat{k} \nabla T)$$ $$\tau_{ij} = -P \delta_{ij} + \mu [\frac{\partial V_i}{\partial x_j} +\frac{\partial V_j}{\partial x_i}-2/3 \nabla V]+\mu \frac{2k}{3(k+3)} \nabla V +\mu \frac{2k}{3(k+3)} \nabla V\approxT_{rot} -T_t$$ 各个方向的温度 $\approx T_{ij} - T_{eq}$ $\mu$ : dynamic viscosity coefficient$\hat{k}$::heat conduction coefficient $$\mu \approx \frac{1}{3}c l$$ c: 声速, l: mean free path]]></content>
      <categories>
        <category>summmer school</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用命令和工具]]></title>
    <url>%2F2018%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E5%B7%A5%E5%85%B7.html</url>
    <content type="text"><![CDATA[vimvim 宏录制 在normal 模式下输入 qa ，开始记录操作，其中 a 代表vim下a 寄存器（可以改成其他寄存器如 b, c ,d )。 结束录制按 q。 使用宏：normal 模式下 输入 n@a , n 代表使用次数， a 是宏存放的位置。]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Note]]></title>
    <url>%2F2018%2FMarkdown-Note.html</url>
    <content type="text"><![CDATA[加粗倾斜 jiacu heiti 倾斜加粗 delete line 分割线 简书 引用 引用 引用 引用 12345[![name](markdown-note/download.jpg &apos;百度&apos;)](http://www.baidu.com)![helloworld][first link][first link]: markdown-note/download.jpg helloworld baidu 文本结构 text 1 text 2 text 3 text 1 text 2 text 3 Tintin A reporter Has poofy orange hair Friends with the world’s most awesome dog Friends with the world’s most awesome dog Haddock A sea captain Has a fantastic beard Loves whiskey Possibly also scotch? 数学公式行间公式恒等式: $$cos^2(x) + sin^2(x) = 1$$ $$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$ 行内公式恒等式：$cos^2(x) + sin^2(x) = 1$,$x=\frac{-b \pm \sqrt{b^2-4ac}}{2a}$ 插入代码单行printf(&quot;helloworld&quot;); 多行插入C++ 代码： 1234printf("helloworld");printf("helloworld");printf("helloworld");printf("helloworld"); 插入Java 代码： 12345public class test &#123; public static void main(String[] args) &#123; System.out.println("helloworld"); &#125;&#125; 插入 Bash 代码: 1$ g++ -O3 test.c -lGl -lGLu -lglut -o test 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 dog bird cat foo foo foo bar bar bar baz baz baz 质能方程 download.jpg 1printf("helloworld"); 插入视频 下载源码Download Markdown-Note.md A=$\begin{bmatrix}4 &amp; 0 &amp; 0\\ 0 &amp; -6 &amp; 0 \\ 0&amp; 0&amp;2 \end{bmatrix}$ 换行三个slash $cond(A) = |A|_1 \cdot |A^{-1}|_1 = 6 * 0.5 = 3$ $cond(A) = |A|_ {\infty} \cdot |A^{-1}|_ {\infty} = 6 * 0.5 = 3$ 空格在 infty前 花括号 {} \{ \} math formula error 行内公式有*， 或重打一遍。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>图片</tag>
        <tag>代码</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
